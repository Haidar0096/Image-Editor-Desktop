// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'editor_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$EditorEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() undo,
    required TResult Function() redo,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addStaticText,
    required TResult Function(String updatedText) staticTextChanged,
    required TResult Function(material.TextStyle updatedTextStyle) staticTextStyleChanged,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addVariableText,
    required TResult Function() variableTextFileChanged,
    required TResult Function(material.TextStyle updatedTextStyle) variableTextStyleChanged,
    required TResult Function() addImage,
    required TResult Function(material.Offset localPosition) dragStart,
    required TResult Function(material.Offset delta) dragUpdate,
    required TResult Function() dragEnd,
    required TResult Function(material.Offset localPosition) tap,
    required TResult Function() removeSelectedElement,
    required TResult Function() bringSelectedElementToFront,
    required TResult Function() clearEditor,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Undo value) undo,
    required TResult Function(Redo value) redo,
    required TResult Function(AddStaticText value) addStaticText,
    required TResult Function(StaticTextChanged value) staticTextChanged,
    required TResult Function(StaticTextStyleChanged value) staticTextStyleChanged,
    required TResult Function(AddVariableText value) addVariableText,
    required TResult Function(VariableTextFileChanged value) variableTextFileChanged,
    required TResult Function(VariableTextStyleChanged value) variableTextStyleChanged,
    required TResult Function(AddImage value) addImage,
    required TResult Function(DragStart value) dragStart,
    required TResult Function(DragUpdate value) dragUpdate,
    required TResult Function(DragEnd value) dragEnd,
    required TResult Function(Tap value) tap,
    required TResult Function(RemoveSelectedElement value) removeSelectedElement,
    required TResult Function(BringSelectedElementToFront value) bringSelectedElementToFront,
    required TResult Function(ClearEditor value) clearEditor,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EditorEventCopyWith<$Res> {
  factory $EditorEventCopyWith(EditorEvent value, $Res Function(EditorEvent) then) = _$EditorEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$EditorEventCopyWithImpl<$Res> implements $EditorEventCopyWith<$Res> {
  _$EditorEventCopyWithImpl(this._value, this._then);

  final EditorEvent _value;
  // ignore: unused_field
  final $Res Function(EditorEvent) _then;
}

/// @nodoc
abstract class _$$UndoCopyWith<$Res> {
  factory _$$UndoCopyWith(_$Undo value, $Res Function(_$Undo) then) = __$$UndoCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UndoCopyWithImpl<$Res> extends _$EditorEventCopyWithImpl<$Res> implements _$$UndoCopyWith<$Res> {
  __$$UndoCopyWithImpl(_$Undo _value, $Res Function(_$Undo) _then) : super(_value, (v) => _then(v as _$Undo));

  @override
  _$Undo get _value => super._value as _$Undo;
}

/// @nodoc

class _$Undo implements Undo {
  const _$Undo();

  @override
  String toString() {
    return 'EditorEvent.undo()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other.runtimeType == runtimeType && other is _$Undo);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() undo,
    required TResult Function() redo,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addStaticText,
    required TResult Function(String updatedText) staticTextChanged,
    required TResult Function(material.TextStyle updatedTextStyle) staticTextStyleChanged,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addVariableText,
    required TResult Function() variableTextFileChanged,
    required TResult Function(material.TextStyle updatedTextStyle) variableTextStyleChanged,
    required TResult Function() addImage,
    required TResult Function(material.Offset localPosition) dragStart,
    required TResult Function(material.Offset delta) dragUpdate,
    required TResult Function() dragEnd,
    required TResult Function(material.Offset localPosition) tap,
    required TResult Function() removeSelectedElement,
    required TResult Function() bringSelectedElementToFront,
    required TResult Function() clearEditor,
  }) {
    return undo();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
  }) {
    return undo?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
    required TResult orElse(),
  }) {
    if (undo != null) {
      return undo();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Undo value) undo,
    required TResult Function(Redo value) redo,
    required TResult Function(AddStaticText value) addStaticText,
    required TResult Function(StaticTextChanged value) staticTextChanged,
    required TResult Function(StaticTextStyleChanged value) staticTextStyleChanged,
    required TResult Function(AddVariableText value) addVariableText,
    required TResult Function(VariableTextFileChanged value) variableTextFileChanged,
    required TResult Function(VariableTextStyleChanged value) variableTextStyleChanged,
    required TResult Function(AddImage value) addImage,
    required TResult Function(DragStart value) dragStart,
    required TResult Function(DragUpdate value) dragUpdate,
    required TResult Function(DragEnd value) dragEnd,
    required TResult Function(Tap value) tap,
    required TResult Function(RemoveSelectedElement value) removeSelectedElement,
    required TResult Function(BringSelectedElementToFront value) bringSelectedElementToFront,
    required TResult Function(ClearEditor value) clearEditor,
  }) {
    return undo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
  }) {
    return undo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
    required TResult orElse(),
  }) {
    if (undo != null) {
      return undo(this);
    }
    return orElse();
  }
}

abstract class Undo implements EditorEvent {
  const factory Undo() = _$Undo;
}

/// @nodoc
abstract class _$$RedoCopyWith<$Res> {
  factory _$$RedoCopyWith(_$Redo value, $Res Function(_$Redo) then) = __$$RedoCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RedoCopyWithImpl<$Res> extends _$EditorEventCopyWithImpl<$Res> implements _$$RedoCopyWith<$Res> {
  __$$RedoCopyWithImpl(_$Redo _value, $Res Function(_$Redo) _then) : super(_value, (v) => _then(v as _$Redo));

  @override
  _$Redo get _value => super._value as _$Redo;
}

/// @nodoc

class _$Redo implements Redo {
  const _$Redo();

  @override
  String toString() {
    return 'EditorEvent.redo()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other.runtimeType == runtimeType && other is _$Redo);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() undo,
    required TResult Function() redo,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addStaticText,
    required TResult Function(String updatedText) staticTextChanged,
    required TResult Function(material.TextStyle updatedTextStyle) staticTextStyleChanged,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addVariableText,
    required TResult Function() variableTextFileChanged,
    required TResult Function(material.TextStyle updatedTextStyle) variableTextStyleChanged,
    required TResult Function() addImage,
    required TResult Function(material.Offset localPosition) dragStart,
    required TResult Function(material.Offset delta) dragUpdate,
    required TResult Function() dragEnd,
    required TResult Function(material.Offset localPosition) tap,
    required TResult Function() removeSelectedElement,
    required TResult Function() bringSelectedElementToFront,
    required TResult Function() clearEditor,
  }) {
    return redo();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
  }) {
    return redo?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
    required TResult orElse(),
  }) {
    if (redo != null) {
      return redo();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Undo value) undo,
    required TResult Function(Redo value) redo,
    required TResult Function(AddStaticText value) addStaticText,
    required TResult Function(StaticTextChanged value) staticTextChanged,
    required TResult Function(StaticTextStyleChanged value) staticTextStyleChanged,
    required TResult Function(AddVariableText value) addVariableText,
    required TResult Function(VariableTextFileChanged value) variableTextFileChanged,
    required TResult Function(VariableTextStyleChanged value) variableTextStyleChanged,
    required TResult Function(AddImage value) addImage,
    required TResult Function(DragStart value) dragStart,
    required TResult Function(DragUpdate value) dragUpdate,
    required TResult Function(DragEnd value) dragEnd,
    required TResult Function(Tap value) tap,
    required TResult Function(RemoveSelectedElement value) removeSelectedElement,
    required TResult Function(BringSelectedElementToFront value) bringSelectedElementToFront,
    required TResult Function(ClearEditor value) clearEditor,
  }) {
    return redo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
  }) {
    return redo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
    required TResult orElse(),
  }) {
    if (redo != null) {
      return redo(this);
    }
    return orElse();
  }
}

abstract class Redo implements EditorEvent {
  const factory Redo() = _$Redo;
}

/// @nodoc
abstract class _$$AddStaticTextCopyWith<$Res> {
  factory _$$AddStaticTextCopyWith(_$AddStaticText value, $Res Function(_$AddStaticText) then) =
      __$$AddStaticTextCopyWithImpl<$Res>;
  $Res call({String initialText, material.TextDirection textDirection, double minWidth, double maxWidth});
}

/// @nodoc
class __$$AddStaticTextCopyWithImpl<$Res> extends _$EditorEventCopyWithImpl<$Res>
    implements _$$AddStaticTextCopyWith<$Res> {
  __$$AddStaticTextCopyWithImpl(_$AddStaticText _value, $Res Function(_$AddStaticText) _then)
      : super(_value, (v) => _then(v as _$AddStaticText));

  @override
  _$AddStaticText get _value => super._value as _$AddStaticText;

  @override
  $Res call({
    Object? initialText = freezed,
    Object? textDirection = freezed,
    Object? minWidth = freezed,
    Object? maxWidth = freezed,
  }) {
    return _then(_$AddStaticText(
      initialText: initialText == freezed
          ? _value.initialText
          : initialText // ignore: cast_nullable_to_non_nullable
              as String,
      textDirection: textDirection == freezed
          ? _value.textDirection
          : textDirection // ignore: cast_nullable_to_non_nullable
              as material.TextDirection,
      minWidth: minWidth == freezed
          ? _value.minWidth
          : minWidth // ignore: cast_nullable_to_non_nullable
              as double,
      maxWidth: maxWidth == freezed
          ? _value.maxWidth
          : maxWidth // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$AddStaticText implements AddStaticText {
  const _$AddStaticText(
      {required this.initialText, required this.textDirection, required this.minWidth, required this.maxWidth});

  /// The initial text of the static text.
  @override
  final String initialText;

  /// The current text direction of the locale.
  @override
  final material.TextDirection textDirection;

  /// The minimum width of the static text.
  @override
  final double minWidth;

  /// The maximum width of the static text.
  @override
  final double maxWidth;

  @override
  String toString() {
    return 'EditorEvent.addStaticText(initialText: $initialText, textDirection: $textDirection, minWidth: $minWidth, maxWidth: $maxWidth)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddStaticText &&
            const DeepCollectionEquality().equals(other.initialText, initialText) &&
            const DeepCollectionEquality().equals(other.textDirection, textDirection) &&
            const DeepCollectionEquality().equals(other.minWidth, minWidth) &&
            const DeepCollectionEquality().equals(other.maxWidth, maxWidth));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(initialText),
      const DeepCollectionEquality().hash(textDirection),
      const DeepCollectionEquality().hash(minWidth),
      const DeepCollectionEquality().hash(maxWidth));

  @JsonKey(ignore: true)
  @override
  _$$AddStaticTextCopyWith<_$AddStaticText> get copyWith =>
      __$$AddStaticTextCopyWithImpl<_$AddStaticText>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() undo,
    required TResult Function() redo,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addStaticText,
    required TResult Function(String updatedText) staticTextChanged,
    required TResult Function(material.TextStyle updatedTextStyle) staticTextStyleChanged,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addVariableText,
    required TResult Function() variableTextFileChanged,
    required TResult Function(material.TextStyle updatedTextStyle) variableTextStyleChanged,
    required TResult Function() addImage,
    required TResult Function(material.Offset localPosition) dragStart,
    required TResult Function(material.Offset delta) dragUpdate,
    required TResult Function() dragEnd,
    required TResult Function(material.Offset localPosition) tap,
    required TResult Function() removeSelectedElement,
    required TResult Function() bringSelectedElementToFront,
    required TResult Function() clearEditor,
  }) {
    return addStaticText(initialText, textDirection, minWidth, maxWidth);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
  }) {
    return addStaticText?.call(initialText, textDirection, minWidth, maxWidth);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
    required TResult orElse(),
  }) {
    if (addStaticText != null) {
      return addStaticText(initialText, textDirection, minWidth, maxWidth);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Undo value) undo,
    required TResult Function(Redo value) redo,
    required TResult Function(AddStaticText value) addStaticText,
    required TResult Function(StaticTextChanged value) staticTextChanged,
    required TResult Function(StaticTextStyleChanged value) staticTextStyleChanged,
    required TResult Function(AddVariableText value) addVariableText,
    required TResult Function(VariableTextFileChanged value) variableTextFileChanged,
    required TResult Function(VariableTextStyleChanged value) variableTextStyleChanged,
    required TResult Function(AddImage value) addImage,
    required TResult Function(DragStart value) dragStart,
    required TResult Function(DragUpdate value) dragUpdate,
    required TResult Function(DragEnd value) dragEnd,
    required TResult Function(Tap value) tap,
    required TResult Function(RemoveSelectedElement value) removeSelectedElement,
    required TResult Function(BringSelectedElementToFront value) bringSelectedElementToFront,
    required TResult Function(ClearEditor value) clearEditor,
  }) {
    return addStaticText(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
  }) {
    return addStaticText?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
    required TResult orElse(),
  }) {
    if (addStaticText != null) {
      return addStaticText(this);
    }
    return orElse();
  }
}

abstract class AddStaticText implements EditorEvent {
  const factory AddStaticText(
      {required final String initialText,
      required final material.TextDirection textDirection,
      required final double minWidth,
      required final double maxWidth}) = _$AddStaticText;

  /// The initial text of the static text.
  String get initialText => throw _privateConstructorUsedError;

  /// The current text direction of the locale.
  material.TextDirection get textDirection => throw _privateConstructorUsedError;

  /// The minimum width of the static text.
  double get minWidth => throw _privateConstructorUsedError;

  /// The maximum width of the static text.
  double get maxWidth => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$AddStaticTextCopyWith<_$AddStaticText> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$StaticTextChangedCopyWith<$Res> {
  factory _$$StaticTextChangedCopyWith(_$StaticTextChanged value, $Res Function(_$StaticTextChanged) then) =
      __$$StaticTextChangedCopyWithImpl<$Res>;
  $Res call({String updatedText});
}

/// @nodoc
class __$$StaticTextChangedCopyWithImpl<$Res> extends _$EditorEventCopyWithImpl<$Res>
    implements _$$StaticTextChangedCopyWith<$Res> {
  __$$StaticTextChangedCopyWithImpl(_$StaticTextChanged _value, $Res Function(_$StaticTextChanged) _then)
      : super(_value, (v) => _then(v as _$StaticTextChanged));

  @override
  _$StaticTextChanged get _value => super._value as _$StaticTextChanged;

  @override
  $Res call({
    Object? updatedText = freezed,
  }) {
    return _then(_$StaticTextChanged(
      updatedText: updatedText == freezed
          ? _value.updatedText
          : updatedText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$StaticTextChanged implements StaticTextChanged {
  const _$StaticTextChanged({required this.updatedText});

  /// The new value of the text.
  @override
  final String updatedText;

  @override
  String toString() {
    return 'EditorEvent.staticTextChanged(updatedText: $updatedText)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StaticTextChanged &&
            const DeepCollectionEquality().equals(other.updatedText, updatedText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(updatedText));

  @JsonKey(ignore: true)
  @override
  _$$StaticTextChangedCopyWith<_$StaticTextChanged> get copyWith =>
      __$$StaticTextChangedCopyWithImpl<_$StaticTextChanged>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() undo,
    required TResult Function() redo,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addStaticText,
    required TResult Function(String updatedText) staticTextChanged,
    required TResult Function(material.TextStyle updatedTextStyle) staticTextStyleChanged,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addVariableText,
    required TResult Function() variableTextFileChanged,
    required TResult Function(material.TextStyle updatedTextStyle) variableTextStyleChanged,
    required TResult Function() addImage,
    required TResult Function(material.Offset localPosition) dragStart,
    required TResult Function(material.Offset delta) dragUpdate,
    required TResult Function() dragEnd,
    required TResult Function(material.Offset localPosition) tap,
    required TResult Function() removeSelectedElement,
    required TResult Function() bringSelectedElementToFront,
    required TResult Function() clearEditor,
  }) {
    return staticTextChanged(updatedText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
  }) {
    return staticTextChanged?.call(updatedText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
    required TResult orElse(),
  }) {
    if (staticTextChanged != null) {
      return staticTextChanged(updatedText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Undo value) undo,
    required TResult Function(Redo value) redo,
    required TResult Function(AddStaticText value) addStaticText,
    required TResult Function(StaticTextChanged value) staticTextChanged,
    required TResult Function(StaticTextStyleChanged value) staticTextStyleChanged,
    required TResult Function(AddVariableText value) addVariableText,
    required TResult Function(VariableTextFileChanged value) variableTextFileChanged,
    required TResult Function(VariableTextStyleChanged value) variableTextStyleChanged,
    required TResult Function(AddImage value) addImage,
    required TResult Function(DragStart value) dragStart,
    required TResult Function(DragUpdate value) dragUpdate,
    required TResult Function(DragEnd value) dragEnd,
    required TResult Function(Tap value) tap,
    required TResult Function(RemoveSelectedElement value) removeSelectedElement,
    required TResult Function(BringSelectedElementToFront value) bringSelectedElementToFront,
    required TResult Function(ClearEditor value) clearEditor,
  }) {
    return staticTextChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
  }) {
    return staticTextChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
    required TResult orElse(),
  }) {
    if (staticTextChanged != null) {
      return staticTextChanged(this);
    }
    return orElse();
  }
}

abstract class StaticTextChanged implements EditorEvent {
  const factory StaticTextChanged({required final String updatedText}) = _$StaticTextChanged;

  /// The new value of the text.
  String get updatedText => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$StaticTextChangedCopyWith<_$StaticTextChanged> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$StaticTextStyleChangedCopyWith<$Res> {
  factory _$$StaticTextStyleChangedCopyWith(
          _$StaticTextStyleChanged value, $Res Function(_$StaticTextStyleChanged) then) =
      __$$StaticTextStyleChangedCopyWithImpl<$Res>;
  $Res call({material.TextStyle updatedTextStyle});
}

/// @nodoc
class __$$StaticTextStyleChangedCopyWithImpl<$Res> extends _$EditorEventCopyWithImpl<$Res>
    implements _$$StaticTextStyleChangedCopyWith<$Res> {
  __$$StaticTextStyleChangedCopyWithImpl(_$StaticTextStyleChanged _value, $Res Function(_$StaticTextStyleChanged) _then)
      : super(_value, (v) => _then(v as _$StaticTextStyleChanged));

  @override
  _$StaticTextStyleChanged get _value => super._value as _$StaticTextStyleChanged;

  @override
  $Res call({
    Object? updatedTextStyle = freezed,
  }) {
    return _then(_$StaticTextStyleChanged(
      updatedTextStyle: updatedTextStyle == freezed
          ? _value.updatedTextStyle
          : updatedTextStyle // ignore: cast_nullable_to_non_nullable
              as material.TextStyle,
    ));
  }
}

/// @nodoc

class _$StaticTextStyleChanged implements StaticTextStyleChanged {
  const _$StaticTextStyleChanged({required this.updatedTextStyle});

  /// The new value of the text style in the element.
  @override
  final material.TextStyle updatedTextStyle;

  @override
  String toString() {
    return 'EditorEvent.staticTextStyleChanged(updatedTextStyle: $updatedTextStyle)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StaticTextStyleChanged &&
            const DeepCollectionEquality().equals(other.updatedTextStyle, updatedTextStyle));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(updatedTextStyle));

  @JsonKey(ignore: true)
  @override
  _$$StaticTextStyleChangedCopyWith<_$StaticTextStyleChanged> get copyWith =>
      __$$StaticTextStyleChangedCopyWithImpl<_$StaticTextStyleChanged>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() undo,
    required TResult Function() redo,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addStaticText,
    required TResult Function(String updatedText) staticTextChanged,
    required TResult Function(material.TextStyle updatedTextStyle) staticTextStyleChanged,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addVariableText,
    required TResult Function() variableTextFileChanged,
    required TResult Function(material.TextStyle updatedTextStyle) variableTextStyleChanged,
    required TResult Function() addImage,
    required TResult Function(material.Offset localPosition) dragStart,
    required TResult Function(material.Offset delta) dragUpdate,
    required TResult Function() dragEnd,
    required TResult Function(material.Offset localPosition) tap,
    required TResult Function() removeSelectedElement,
    required TResult Function() bringSelectedElementToFront,
    required TResult Function() clearEditor,
  }) {
    return staticTextStyleChanged(updatedTextStyle);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
  }) {
    return staticTextStyleChanged?.call(updatedTextStyle);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
    required TResult orElse(),
  }) {
    if (staticTextStyleChanged != null) {
      return staticTextStyleChanged(updatedTextStyle);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Undo value) undo,
    required TResult Function(Redo value) redo,
    required TResult Function(AddStaticText value) addStaticText,
    required TResult Function(StaticTextChanged value) staticTextChanged,
    required TResult Function(StaticTextStyleChanged value) staticTextStyleChanged,
    required TResult Function(AddVariableText value) addVariableText,
    required TResult Function(VariableTextFileChanged value) variableTextFileChanged,
    required TResult Function(VariableTextStyleChanged value) variableTextStyleChanged,
    required TResult Function(AddImage value) addImage,
    required TResult Function(DragStart value) dragStart,
    required TResult Function(DragUpdate value) dragUpdate,
    required TResult Function(DragEnd value) dragEnd,
    required TResult Function(Tap value) tap,
    required TResult Function(RemoveSelectedElement value) removeSelectedElement,
    required TResult Function(BringSelectedElementToFront value) bringSelectedElementToFront,
    required TResult Function(ClearEditor value) clearEditor,
  }) {
    return staticTextStyleChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
  }) {
    return staticTextStyleChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
    required TResult orElse(),
  }) {
    if (staticTextStyleChanged != null) {
      return staticTextStyleChanged(this);
    }
    return orElse();
  }
}

abstract class StaticTextStyleChanged implements EditorEvent {
  const factory StaticTextStyleChanged({required final material.TextStyle updatedTextStyle}) = _$StaticTextStyleChanged;

  /// The new value of the text style in the element.
  material.TextStyle get updatedTextStyle => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$StaticTextStyleChangedCopyWith<_$StaticTextStyleChanged> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AddVariableTextCopyWith<$Res> {
  factory _$$AddVariableTextCopyWith(_$AddVariableText value, $Res Function(_$AddVariableText) then) =
      __$$AddVariableTextCopyWithImpl<$Res>;
  $Res call({String initialText, material.TextDirection textDirection, double minWidth, double maxWidth});
}

/// @nodoc
class __$$AddVariableTextCopyWithImpl<$Res> extends _$EditorEventCopyWithImpl<$Res>
    implements _$$AddVariableTextCopyWith<$Res> {
  __$$AddVariableTextCopyWithImpl(_$AddVariableText _value, $Res Function(_$AddVariableText) _then)
      : super(_value, (v) => _then(v as _$AddVariableText));

  @override
  _$AddVariableText get _value => super._value as _$AddVariableText;

  @override
  $Res call({
    Object? initialText = freezed,
    Object? textDirection = freezed,
    Object? minWidth = freezed,
    Object? maxWidth = freezed,
  }) {
    return _then(_$AddVariableText(
      initialText: initialText == freezed
          ? _value.initialText
          : initialText // ignore: cast_nullable_to_non_nullable
              as String,
      textDirection: textDirection == freezed
          ? _value.textDirection
          : textDirection // ignore: cast_nullable_to_non_nullable
              as material.TextDirection,
      minWidth: minWidth == freezed
          ? _value.minWidth
          : minWidth // ignore: cast_nullable_to_non_nullable
              as double,
      maxWidth: maxWidth == freezed
          ? _value.maxWidth
          : maxWidth // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$AddVariableText implements AddVariableText {
  const _$AddVariableText(
      {required this.initialText, required this.textDirection, required this.minWidth, required this.maxWidth});

  /// The initial text of the variable text.
  @override
  final String initialText;

  /// The current text direction.
  @override
  final material.TextDirection textDirection;

  /// The minimum width of the variable text placeholder.
  @override
  final double minWidth;

  /// The maximum width of the variable text placeholder.
  @override
  final double maxWidth;

  @override
  String toString() {
    return 'EditorEvent.addVariableText(initialText: $initialText, textDirection: $textDirection, minWidth: $minWidth, maxWidth: $maxWidth)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddVariableText &&
            const DeepCollectionEquality().equals(other.initialText, initialText) &&
            const DeepCollectionEquality().equals(other.textDirection, textDirection) &&
            const DeepCollectionEquality().equals(other.minWidth, minWidth) &&
            const DeepCollectionEquality().equals(other.maxWidth, maxWidth));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(initialText),
      const DeepCollectionEquality().hash(textDirection),
      const DeepCollectionEquality().hash(minWidth),
      const DeepCollectionEquality().hash(maxWidth));

  @JsonKey(ignore: true)
  @override
  _$$AddVariableTextCopyWith<_$AddVariableText> get copyWith =>
      __$$AddVariableTextCopyWithImpl<_$AddVariableText>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() undo,
    required TResult Function() redo,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addStaticText,
    required TResult Function(String updatedText) staticTextChanged,
    required TResult Function(material.TextStyle updatedTextStyle) staticTextStyleChanged,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addVariableText,
    required TResult Function() variableTextFileChanged,
    required TResult Function(material.TextStyle updatedTextStyle) variableTextStyleChanged,
    required TResult Function() addImage,
    required TResult Function(material.Offset localPosition) dragStart,
    required TResult Function(material.Offset delta) dragUpdate,
    required TResult Function() dragEnd,
    required TResult Function(material.Offset localPosition) tap,
    required TResult Function() removeSelectedElement,
    required TResult Function() bringSelectedElementToFront,
    required TResult Function() clearEditor,
  }) {
    return addVariableText(initialText, textDirection, minWidth, maxWidth);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
  }) {
    return addVariableText?.call(initialText, textDirection, minWidth, maxWidth);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
    required TResult orElse(),
  }) {
    if (addVariableText != null) {
      return addVariableText(initialText, textDirection, minWidth, maxWidth);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Undo value) undo,
    required TResult Function(Redo value) redo,
    required TResult Function(AddStaticText value) addStaticText,
    required TResult Function(StaticTextChanged value) staticTextChanged,
    required TResult Function(StaticTextStyleChanged value) staticTextStyleChanged,
    required TResult Function(AddVariableText value) addVariableText,
    required TResult Function(VariableTextFileChanged value) variableTextFileChanged,
    required TResult Function(VariableTextStyleChanged value) variableTextStyleChanged,
    required TResult Function(AddImage value) addImage,
    required TResult Function(DragStart value) dragStart,
    required TResult Function(DragUpdate value) dragUpdate,
    required TResult Function(DragEnd value) dragEnd,
    required TResult Function(Tap value) tap,
    required TResult Function(RemoveSelectedElement value) removeSelectedElement,
    required TResult Function(BringSelectedElementToFront value) bringSelectedElementToFront,
    required TResult Function(ClearEditor value) clearEditor,
  }) {
    return addVariableText(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
  }) {
    return addVariableText?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
    required TResult orElse(),
  }) {
    if (addVariableText != null) {
      return addVariableText(this);
    }
    return orElse();
  }
}

abstract class AddVariableText implements EditorEvent {
  const factory AddVariableText(
      {required final String initialText,
      required final material.TextDirection textDirection,
      required final double minWidth,
      required final double maxWidth}) = _$AddVariableText;

  /// The initial text of the variable text.
  String get initialText => throw _privateConstructorUsedError;

  /// The current text direction.
  material.TextDirection get textDirection => throw _privateConstructorUsedError;

  /// The minimum width of the variable text placeholder.
  double get minWidth => throw _privateConstructorUsedError;

  /// The maximum width of the variable text placeholder.
  double get maxWidth => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$AddVariableTextCopyWith<_$AddVariableText> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$VariableTextFileChangedCopyWith<$Res> {
  factory _$$VariableTextFileChangedCopyWith(
          _$VariableTextFileChanged value, $Res Function(_$VariableTextFileChanged) then) =
      __$$VariableTextFileChangedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$VariableTextFileChangedCopyWithImpl<$Res> extends _$EditorEventCopyWithImpl<$Res>
    implements _$$VariableTextFileChangedCopyWith<$Res> {
  __$$VariableTextFileChangedCopyWithImpl(
      _$VariableTextFileChanged _value, $Res Function(_$VariableTextFileChanged) _then)
      : super(_value, (v) => _then(v as _$VariableTextFileChanged));

  @override
  _$VariableTextFileChanged get _value => super._value as _$VariableTextFileChanged;
}

/// @nodoc

class _$VariableTextFileChanged implements VariableTextFileChanged {
  const _$VariableTextFileChanged();

  @override
  String toString() {
    return 'EditorEvent.variableTextFileChanged()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other.runtimeType == runtimeType && other is _$VariableTextFileChanged);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() undo,
    required TResult Function() redo,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addStaticText,
    required TResult Function(String updatedText) staticTextChanged,
    required TResult Function(material.TextStyle updatedTextStyle) staticTextStyleChanged,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addVariableText,
    required TResult Function() variableTextFileChanged,
    required TResult Function(material.TextStyle updatedTextStyle) variableTextStyleChanged,
    required TResult Function() addImage,
    required TResult Function(material.Offset localPosition) dragStart,
    required TResult Function(material.Offset delta) dragUpdate,
    required TResult Function() dragEnd,
    required TResult Function(material.Offset localPosition) tap,
    required TResult Function() removeSelectedElement,
    required TResult Function() bringSelectedElementToFront,
    required TResult Function() clearEditor,
  }) {
    return variableTextFileChanged();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
  }) {
    return variableTextFileChanged?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
    required TResult orElse(),
  }) {
    if (variableTextFileChanged != null) {
      return variableTextFileChanged();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Undo value) undo,
    required TResult Function(Redo value) redo,
    required TResult Function(AddStaticText value) addStaticText,
    required TResult Function(StaticTextChanged value) staticTextChanged,
    required TResult Function(StaticTextStyleChanged value) staticTextStyleChanged,
    required TResult Function(AddVariableText value) addVariableText,
    required TResult Function(VariableTextFileChanged value) variableTextFileChanged,
    required TResult Function(VariableTextStyleChanged value) variableTextStyleChanged,
    required TResult Function(AddImage value) addImage,
    required TResult Function(DragStart value) dragStart,
    required TResult Function(DragUpdate value) dragUpdate,
    required TResult Function(DragEnd value) dragEnd,
    required TResult Function(Tap value) tap,
    required TResult Function(RemoveSelectedElement value) removeSelectedElement,
    required TResult Function(BringSelectedElementToFront value) bringSelectedElementToFront,
    required TResult Function(ClearEditor value) clearEditor,
  }) {
    return variableTextFileChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
  }) {
    return variableTextFileChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
    required TResult orElse(),
  }) {
    if (variableTextFileChanged != null) {
      return variableTextFileChanged(this);
    }
    return orElse();
  }
}

abstract class VariableTextFileChanged implements EditorEvent {
  const factory VariableTextFileChanged() = _$VariableTextFileChanged;
}

/// @nodoc
abstract class _$$VariableTextStyleChangedCopyWith<$Res> {
  factory _$$VariableTextStyleChangedCopyWith(
          _$VariableTextStyleChanged value, $Res Function(_$VariableTextStyleChanged) then) =
      __$$VariableTextStyleChangedCopyWithImpl<$Res>;
  $Res call({material.TextStyle updatedTextStyle});
}

/// @nodoc
class __$$VariableTextStyleChangedCopyWithImpl<$Res> extends _$EditorEventCopyWithImpl<$Res>
    implements _$$VariableTextStyleChangedCopyWith<$Res> {
  __$$VariableTextStyleChangedCopyWithImpl(
      _$VariableTextStyleChanged _value, $Res Function(_$VariableTextStyleChanged) _then)
      : super(_value, (v) => _then(v as _$VariableTextStyleChanged));

  @override
  _$VariableTextStyleChanged get _value => super._value as _$VariableTextStyleChanged;

  @override
  $Res call({
    Object? updatedTextStyle = freezed,
  }) {
    return _then(_$VariableTextStyleChanged(
      updatedTextStyle: updatedTextStyle == freezed
          ? _value.updatedTextStyle
          : updatedTextStyle // ignore: cast_nullable_to_non_nullable
              as material.TextStyle,
    ));
  }
}

/// @nodoc

class _$VariableTextStyleChanged implements VariableTextStyleChanged {
  const _$VariableTextStyleChanged({required this.updatedTextStyle});

  /// The new value of the text style in the element.
  @override
  final material.TextStyle updatedTextStyle;

  @override
  String toString() {
    return 'EditorEvent.variableTextStyleChanged(updatedTextStyle: $updatedTextStyle)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VariableTextStyleChanged &&
            const DeepCollectionEquality().equals(other.updatedTextStyle, updatedTextStyle));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(updatedTextStyle));

  @JsonKey(ignore: true)
  @override
  _$$VariableTextStyleChangedCopyWith<_$VariableTextStyleChanged> get copyWith =>
      __$$VariableTextStyleChangedCopyWithImpl<_$VariableTextStyleChanged>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() undo,
    required TResult Function() redo,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addStaticText,
    required TResult Function(String updatedText) staticTextChanged,
    required TResult Function(material.TextStyle updatedTextStyle) staticTextStyleChanged,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addVariableText,
    required TResult Function() variableTextFileChanged,
    required TResult Function(material.TextStyle updatedTextStyle) variableTextStyleChanged,
    required TResult Function() addImage,
    required TResult Function(material.Offset localPosition) dragStart,
    required TResult Function(material.Offset delta) dragUpdate,
    required TResult Function() dragEnd,
    required TResult Function(material.Offset localPosition) tap,
    required TResult Function() removeSelectedElement,
    required TResult Function() bringSelectedElementToFront,
    required TResult Function() clearEditor,
  }) {
    return variableTextStyleChanged(updatedTextStyle);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
  }) {
    return variableTextStyleChanged?.call(updatedTextStyle);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
    required TResult orElse(),
  }) {
    if (variableTextStyleChanged != null) {
      return variableTextStyleChanged(updatedTextStyle);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Undo value) undo,
    required TResult Function(Redo value) redo,
    required TResult Function(AddStaticText value) addStaticText,
    required TResult Function(StaticTextChanged value) staticTextChanged,
    required TResult Function(StaticTextStyleChanged value) staticTextStyleChanged,
    required TResult Function(AddVariableText value) addVariableText,
    required TResult Function(VariableTextFileChanged value) variableTextFileChanged,
    required TResult Function(VariableTextStyleChanged value) variableTextStyleChanged,
    required TResult Function(AddImage value) addImage,
    required TResult Function(DragStart value) dragStart,
    required TResult Function(DragUpdate value) dragUpdate,
    required TResult Function(DragEnd value) dragEnd,
    required TResult Function(Tap value) tap,
    required TResult Function(RemoveSelectedElement value) removeSelectedElement,
    required TResult Function(BringSelectedElementToFront value) bringSelectedElementToFront,
    required TResult Function(ClearEditor value) clearEditor,
  }) {
    return variableTextStyleChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
  }) {
    return variableTextStyleChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
    required TResult orElse(),
  }) {
    if (variableTextStyleChanged != null) {
      return variableTextStyleChanged(this);
    }
    return orElse();
  }
}

abstract class VariableTextStyleChanged implements EditorEvent {
  const factory VariableTextStyleChanged({required final material.TextStyle updatedTextStyle}) =
      _$VariableTextStyleChanged;

  /// The new value of the text style in the element.
  material.TextStyle get updatedTextStyle => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$VariableTextStyleChangedCopyWith<_$VariableTextStyleChanged> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AddImageCopyWith<$Res> {
  factory _$$AddImageCopyWith(_$AddImage value, $Res Function(_$AddImage) then) = __$$AddImageCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AddImageCopyWithImpl<$Res> extends _$EditorEventCopyWithImpl<$Res> implements _$$AddImageCopyWith<$Res> {
  __$$AddImageCopyWithImpl(_$AddImage _value, $Res Function(_$AddImage) _then)
      : super(_value, (v) => _then(v as _$AddImage));

  @override
  _$AddImage get _value => super._value as _$AddImage;
}

/// @nodoc

class _$AddImage implements AddImage {
  const _$AddImage();

  @override
  String toString() {
    return 'EditorEvent.addImage()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other.runtimeType == runtimeType && other is _$AddImage);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() undo,
    required TResult Function() redo,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addStaticText,
    required TResult Function(String updatedText) staticTextChanged,
    required TResult Function(material.TextStyle updatedTextStyle) staticTextStyleChanged,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addVariableText,
    required TResult Function() variableTextFileChanged,
    required TResult Function(material.TextStyle updatedTextStyle) variableTextStyleChanged,
    required TResult Function() addImage,
    required TResult Function(material.Offset localPosition) dragStart,
    required TResult Function(material.Offset delta) dragUpdate,
    required TResult Function() dragEnd,
    required TResult Function(material.Offset localPosition) tap,
    required TResult Function() removeSelectedElement,
    required TResult Function() bringSelectedElementToFront,
    required TResult Function() clearEditor,
  }) {
    return addImage();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
  }) {
    return addImage?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
    required TResult orElse(),
  }) {
    if (addImage != null) {
      return addImage();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Undo value) undo,
    required TResult Function(Redo value) redo,
    required TResult Function(AddStaticText value) addStaticText,
    required TResult Function(StaticTextChanged value) staticTextChanged,
    required TResult Function(StaticTextStyleChanged value) staticTextStyleChanged,
    required TResult Function(AddVariableText value) addVariableText,
    required TResult Function(VariableTextFileChanged value) variableTextFileChanged,
    required TResult Function(VariableTextStyleChanged value) variableTextStyleChanged,
    required TResult Function(AddImage value) addImage,
    required TResult Function(DragStart value) dragStart,
    required TResult Function(DragUpdate value) dragUpdate,
    required TResult Function(DragEnd value) dragEnd,
    required TResult Function(Tap value) tap,
    required TResult Function(RemoveSelectedElement value) removeSelectedElement,
    required TResult Function(BringSelectedElementToFront value) bringSelectedElementToFront,
    required TResult Function(ClearEditor value) clearEditor,
  }) {
    return addImage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
  }) {
    return addImage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
    required TResult orElse(),
  }) {
    if (addImage != null) {
      return addImage(this);
    }
    return orElse();
  }
}

abstract class AddImage implements EditorEvent {
  const factory AddImage() = _$AddImage;
}

/// @nodoc
abstract class _$$DragStartCopyWith<$Res> {
  factory _$$DragStartCopyWith(_$DragStart value, $Res Function(_$DragStart) then) = __$$DragStartCopyWithImpl<$Res>;
  $Res call({material.Offset localPosition});
}

/// @nodoc
class __$$DragStartCopyWithImpl<$Res> extends _$EditorEventCopyWithImpl<$Res> implements _$$DragStartCopyWith<$Res> {
  __$$DragStartCopyWithImpl(_$DragStart _value, $Res Function(_$DragStart) _then)
      : super(_value, (v) => _then(v as _$DragStart));

  @override
  _$DragStart get _value => super._value as _$DragStart;

  @override
  $Res call({
    Object? localPosition = freezed,
  }) {
    return _then(_$DragStart(
      localPosition == freezed
          ? _value.localPosition
          : localPosition // ignore: cast_nullable_to_non_nullable
              as material.Offset,
    ));
  }
}

/// @nodoc

class _$DragStart implements DragStart {
  const _$DragStart(this.localPosition);

  /// The local position in the editor widget where the drag started.
  @override
  final material.Offset localPosition;

  @override
  String toString() {
    return 'EditorEvent.dragStart(localPosition: $localPosition)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DragStart &&
            const DeepCollectionEquality().equals(other.localPosition, localPosition));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(localPosition));

  @JsonKey(ignore: true)
  @override
  _$$DragStartCopyWith<_$DragStart> get copyWith => __$$DragStartCopyWithImpl<_$DragStart>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() undo,
    required TResult Function() redo,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addStaticText,
    required TResult Function(String updatedText) staticTextChanged,
    required TResult Function(material.TextStyle updatedTextStyle) staticTextStyleChanged,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addVariableText,
    required TResult Function() variableTextFileChanged,
    required TResult Function(material.TextStyle updatedTextStyle) variableTextStyleChanged,
    required TResult Function() addImage,
    required TResult Function(material.Offset localPosition) dragStart,
    required TResult Function(material.Offset delta) dragUpdate,
    required TResult Function() dragEnd,
    required TResult Function(material.Offset localPosition) tap,
    required TResult Function() removeSelectedElement,
    required TResult Function() bringSelectedElementToFront,
    required TResult Function() clearEditor,
  }) {
    return dragStart(localPosition);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
  }) {
    return dragStart?.call(localPosition);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
    required TResult orElse(),
  }) {
    if (dragStart != null) {
      return dragStart(localPosition);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Undo value) undo,
    required TResult Function(Redo value) redo,
    required TResult Function(AddStaticText value) addStaticText,
    required TResult Function(StaticTextChanged value) staticTextChanged,
    required TResult Function(StaticTextStyleChanged value) staticTextStyleChanged,
    required TResult Function(AddVariableText value) addVariableText,
    required TResult Function(VariableTextFileChanged value) variableTextFileChanged,
    required TResult Function(VariableTextStyleChanged value) variableTextStyleChanged,
    required TResult Function(AddImage value) addImage,
    required TResult Function(DragStart value) dragStart,
    required TResult Function(DragUpdate value) dragUpdate,
    required TResult Function(DragEnd value) dragEnd,
    required TResult Function(Tap value) tap,
    required TResult Function(RemoveSelectedElement value) removeSelectedElement,
    required TResult Function(BringSelectedElementToFront value) bringSelectedElementToFront,
    required TResult Function(ClearEditor value) clearEditor,
  }) {
    return dragStart(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
  }) {
    return dragStart?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
    required TResult orElse(),
  }) {
    if (dragStart != null) {
      return dragStart(this);
    }
    return orElse();
  }
}

abstract class DragStart implements EditorEvent {
  const factory DragStart(final material.Offset localPosition) = _$DragStart;

  /// The local position in the editor widget where the drag started.
  material.Offset get localPosition => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$DragStartCopyWith<_$DragStart> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DragUpdateCopyWith<$Res> {
  factory _$$DragUpdateCopyWith(_$DragUpdate value, $Res Function(_$DragUpdate) then) =
      __$$DragUpdateCopyWithImpl<$Res>;
  $Res call({material.Offset delta});
}

/// @nodoc
class __$$DragUpdateCopyWithImpl<$Res> extends _$EditorEventCopyWithImpl<$Res> implements _$$DragUpdateCopyWith<$Res> {
  __$$DragUpdateCopyWithImpl(_$DragUpdate _value, $Res Function(_$DragUpdate) _then)
      : super(_value, (v) => _then(v as _$DragUpdate));

  @override
  _$DragUpdate get _value => super._value as _$DragUpdate;

  @override
  $Res call({
    Object? delta = freezed,
  }) {
    return _then(_$DragUpdate(
      delta == freezed
          ? _value.delta
          : delta // ignore: cast_nullable_to_non_nullable
              as material.Offset,
    ));
  }
}

/// @nodoc

class _$DragUpdate implements DragUpdate {
  const _$DragUpdate(this.delta);

  /// The delta of the drag (i.e. the amount of the drag).
  @override
  final material.Offset delta;

  @override
  String toString() {
    return 'EditorEvent.dragUpdate(delta: $delta)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DragUpdate &&
            const DeepCollectionEquality().equals(other.delta, delta));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(delta));

  @JsonKey(ignore: true)
  @override
  _$$DragUpdateCopyWith<_$DragUpdate> get copyWith => __$$DragUpdateCopyWithImpl<_$DragUpdate>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() undo,
    required TResult Function() redo,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addStaticText,
    required TResult Function(String updatedText) staticTextChanged,
    required TResult Function(material.TextStyle updatedTextStyle) staticTextStyleChanged,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addVariableText,
    required TResult Function() variableTextFileChanged,
    required TResult Function(material.TextStyle updatedTextStyle) variableTextStyleChanged,
    required TResult Function() addImage,
    required TResult Function(material.Offset localPosition) dragStart,
    required TResult Function(material.Offset delta) dragUpdate,
    required TResult Function() dragEnd,
    required TResult Function(material.Offset localPosition) tap,
    required TResult Function() removeSelectedElement,
    required TResult Function() bringSelectedElementToFront,
    required TResult Function() clearEditor,
  }) {
    return dragUpdate(delta);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
  }) {
    return dragUpdate?.call(delta);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
    required TResult orElse(),
  }) {
    if (dragUpdate != null) {
      return dragUpdate(delta);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Undo value) undo,
    required TResult Function(Redo value) redo,
    required TResult Function(AddStaticText value) addStaticText,
    required TResult Function(StaticTextChanged value) staticTextChanged,
    required TResult Function(StaticTextStyleChanged value) staticTextStyleChanged,
    required TResult Function(AddVariableText value) addVariableText,
    required TResult Function(VariableTextFileChanged value) variableTextFileChanged,
    required TResult Function(VariableTextStyleChanged value) variableTextStyleChanged,
    required TResult Function(AddImage value) addImage,
    required TResult Function(DragStart value) dragStart,
    required TResult Function(DragUpdate value) dragUpdate,
    required TResult Function(DragEnd value) dragEnd,
    required TResult Function(Tap value) tap,
    required TResult Function(RemoveSelectedElement value) removeSelectedElement,
    required TResult Function(BringSelectedElementToFront value) bringSelectedElementToFront,
    required TResult Function(ClearEditor value) clearEditor,
  }) {
    return dragUpdate(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
  }) {
    return dragUpdate?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
    required TResult orElse(),
  }) {
    if (dragUpdate != null) {
      return dragUpdate(this);
    }
    return orElse();
  }
}

abstract class DragUpdate implements EditorEvent {
  const factory DragUpdate(final material.Offset delta) = _$DragUpdate;

  /// The delta of the drag (i.e. the amount of the drag).
  material.Offset get delta => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$DragUpdateCopyWith<_$DragUpdate> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DragEndCopyWith<$Res> {
  factory _$$DragEndCopyWith(_$DragEnd value, $Res Function(_$DragEnd) then) = __$$DragEndCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DragEndCopyWithImpl<$Res> extends _$EditorEventCopyWithImpl<$Res> implements _$$DragEndCopyWith<$Res> {
  __$$DragEndCopyWithImpl(_$DragEnd _value, $Res Function(_$DragEnd) _then)
      : super(_value, (v) => _then(v as _$DragEnd));

  @override
  _$DragEnd get _value => super._value as _$DragEnd;
}

/// @nodoc

class _$DragEnd implements DragEnd {
  const _$DragEnd();

  @override
  String toString() {
    return 'EditorEvent.dragEnd()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other.runtimeType == runtimeType && other is _$DragEnd);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() undo,
    required TResult Function() redo,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addStaticText,
    required TResult Function(String updatedText) staticTextChanged,
    required TResult Function(material.TextStyle updatedTextStyle) staticTextStyleChanged,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addVariableText,
    required TResult Function() variableTextFileChanged,
    required TResult Function(material.TextStyle updatedTextStyle) variableTextStyleChanged,
    required TResult Function() addImage,
    required TResult Function(material.Offset localPosition) dragStart,
    required TResult Function(material.Offset delta) dragUpdate,
    required TResult Function() dragEnd,
    required TResult Function(material.Offset localPosition) tap,
    required TResult Function() removeSelectedElement,
    required TResult Function() bringSelectedElementToFront,
    required TResult Function() clearEditor,
  }) {
    return dragEnd();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
  }) {
    return dragEnd?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
    required TResult orElse(),
  }) {
    if (dragEnd != null) {
      return dragEnd();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Undo value) undo,
    required TResult Function(Redo value) redo,
    required TResult Function(AddStaticText value) addStaticText,
    required TResult Function(StaticTextChanged value) staticTextChanged,
    required TResult Function(StaticTextStyleChanged value) staticTextStyleChanged,
    required TResult Function(AddVariableText value) addVariableText,
    required TResult Function(VariableTextFileChanged value) variableTextFileChanged,
    required TResult Function(VariableTextStyleChanged value) variableTextStyleChanged,
    required TResult Function(AddImage value) addImage,
    required TResult Function(DragStart value) dragStart,
    required TResult Function(DragUpdate value) dragUpdate,
    required TResult Function(DragEnd value) dragEnd,
    required TResult Function(Tap value) tap,
    required TResult Function(RemoveSelectedElement value) removeSelectedElement,
    required TResult Function(BringSelectedElementToFront value) bringSelectedElementToFront,
    required TResult Function(ClearEditor value) clearEditor,
  }) {
    return dragEnd(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
  }) {
    return dragEnd?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
    required TResult orElse(),
  }) {
    if (dragEnd != null) {
      return dragEnd(this);
    }
    return orElse();
  }
}

abstract class DragEnd implements EditorEvent {
  const factory DragEnd() = _$DragEnd;
}

/// @nodoc
abstract class _$$TapCopyWith<$Res> {
  factory _$$TapCopyWith(_$Tap value, $Res Function(_$Tap) then) = __$$TapCopyWithImpl<$Res>;
  $Res call({material.Offset localPosition});
}

/// @nodoc
class __$$TapCopyWithImpl<$Res> extends _$EditorEventCopyWithImpl<$Res> implements _$$TapCopyWith<$Res> {
  __$$TapCopyWithImpl(_$Tap _value, $Res Function(_$Tap) _then) : super(_value, (v) => _then(v as _$Tap));

  @override
  _$Tap get _value => super._value as _$Tap;

  @override
  $Res call({
    Object? localPosition = freezed,
  }) {
    return _then(_$Tap(
      localPosition == freezed
          ? _value.localPosition
          : localPosition // ignore: cast_nullable_to_non_nullable
              as material.Offset,
    ));
  }
}

/// @nodoc

class _$Tap implements Tap {
  const _$Tap(this.localPosition);

  /// The local position in the editor widget where the tap has happened.
  @override
  final material.Offset localPosition;

  @override
  String toString() {
    return 'EditorEvent.tap(localPosition: $localPosition)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Tap &&
            const DeepCollectionEquality().equals(other.localPosition, localPosition));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(localPosition));

  @JsonKey(ignore: true)
  @override
  _$$TapCopyWith<_$Tap> get copyWith => __$$TapCopyWithImpl<_$Tap>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() undo,
    required TResult Function() redo,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addStaticText,
    required TResult Function(String updatedText) staticTextChanged,
    required TResult Function(material.TextStyle updatedTextStyle) staticTextStyleChanged,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addVariableText,
    required TResult Function() variableTextFileChanged,
    required TResult Function(material.TextStyle updatedTextStyle) variableTextStyleChanged,
    required TResult Function() addImage,
    required TResult Function(material.Offset localPosition) dragStart,
    required TResult Function(material.Offset delta) dragUpdate,
    required TResult Function() dragEnd,
    required TResult Function(material.Offset localPosition) tap,
    required TResult Function() removeSelectedElement,
    required TResult Function() bringSelectedElementToFront,
    required TResult Function() clearEditor,
  }) {
    return tap(localPosition);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
  }) {
    return tap?.call(localPosition);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
    required TResult orElse(),
  }) {
    if (tap != null) {
      return tap(localPosition);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Undo value) undo,
    required TResult Function(Redo value) redo,
    required TResult Function(AddStaticText value) addStaticText,
    required TResult Function(StaticTextChanged value) staticTextChanged,
    required TResult Function(StaticTextStyleChanged value) staticTextStyleChanged,
    required TResult Function(AddVariableText value) addVariableText,
    required TResult Function(VariableTextFileChanged value) variableTextFileChanged,
    required TResult Function(VariableTextStyleChanged value) variableTextStyleChanged,
    required TResult Function(AddImage value) addImage,
    required TResult Function(DragStart value) dragStart,
    required TResult Function(DragUpdate value) dragUpdate,
    required TResult Function(DragEnd value) dragEnd,
    required TResult Function(Tap value) tap,
    required TResult Function(RemoveSelectedElement value) removeSelectedElement,
    required TResult Function(BringSelectedElementToFront value) bringSelectedElementToFront,
    required TResult Function(ClearEditor value) clearEditor,
  }) {
    return tap(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
  }) {
    return tap?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
    required TResult orElse(),
  }) {
    if (tap != null) {
      return tap(this);
    }
    return orElse();
  }
}

abstract class Tap implements EditorEvent {
  const factory Tap(final material.Offset localPosition) = _$Tap;

  /// The local position in the editor widget where the tap has happened.
  material.Offset get localPosition => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$TapCopyWith<_$Tap> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RemoveSelectedElementCopyWith<$Res> {
  factory _$$RemoveSelectedElementCopyWith(_$RemoveSelectedElement value, $Res Function(_$RemoveSelectedElement) then) =
      __$$RemoveSelectedElementCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RemoveSelectedElementCopyWithImpl<$Res> extends _$EditorEventCopyWithImpl<$Res>
    implements _$$RemoveSelectedElementCopyWith<$Res> {
  __$$RemoveSelectedElementCopyWithImpl(_$RemoveSelectedElement _value, $Res Function(_$RemoveSelectedElement) _then)
      : super(_value, (v) => _then(v as _$RemoveSelectedElement));

  @override
  _$RemoveSelectedElement get _value => super._value as _$RemoveSelectedElement;
}

/// @nodoc

class _$RemoveSelectedElement implements RemoveSelectedElement {
  const _$RemoveSelectedElement();

  @override
  String toString() {
    return 'EditorEvent.removeSelectedElement()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other.runtimeType == runtimeType && other is _$RemoveSelectedElement);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() undo,
    required TResult Function() redo,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addStaticText,
    required TResult Function(String updatedText) staticTextChanged,
    required TResult Function(material.TextStyle updatedTextStyle) staticTextStyleChanged,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addVariableText,
    required TResult Function() variableTextFileChanged,
    required TResult Function(material.TextStyle updatedTextStyle) variableTextStyleChanged,
    required TResult Function() addImage,
    required TResult Function(material.Offset localPosition) dragStart,
    required TResult Function(material.Offset delta) dragUpdate,
    required TResult Function() dragEnd,
    required TResult Function(material.Offset localPosition) tap,
    required TResult Function() removeSelectedElement,
    required TResult Function() bringSelectedElementToFront,
    required TResult Function() clearEditor,
  }) {
    return removeSelectedElement();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
  }) {
    return removeSelectedElement?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
    required TResult orElse(),
  }) {
    if (removeSelectedElement != null) {
      return removeSelectedElement();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Undo value) undo,
    required TResult Function(Redo value) redo,
    required TResult Function(AddStaticText value) addStaticText,
    required TResult Function(StaticTextChanged value) staticTextChanged,
    required TResult Function(StaticTextStyleChanged value) staticTextStyleChanged,
    required TResult Function(AddVariableText value) addVariableText,
    required TResult Function(VariableTextFileChanged value) variableTextFileChanged,
    required TResult Function(VariableTextStyleChanged value) variableTextStyleChanged,
    required TResult Function(AddImage value) addImage,
    required TResult Function(DragStart value) dragStart,
    required TResult Function(DragUpdate value) dragUpdate,
    required TResult Function(DragEnd value) dragEnd,
    required TResult Function(Tap value) tap,
    required TResult Function(RemoveSelectedElement value) removeSelectedElement,
    required TResult Function(BringSelectedElementToFront value) bringSelectedElementToFront,
    required TResult Function(ClearEditor value) clearEditor,
  }) {
    return removeSelectedElement(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
  }) {
    return removeSelectedElement?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
    required TResult orElse(),
  }) {
    if (removeSelectedElement != null) {
      return removeSelectedElement(this);
    }
    return orElse();
  }
}

abstract class RemoveSelectedElement implements EditorEvent {
  const factory RemoveSelectedElement() = _$RemoveSelectedElement;
}

/// @nodoc
abstract class _$$BringSelectedElementToFrontCopyWith<$Res> {
  factory _$$BringSelectedElementToFrontCopyWith(
          _$BringSelectedElementToFront value, $Res Function(_$BringSelectedElementToFront) then) =
      __$$BringSelectedElementToFrontCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BringSelectedElementToFrontCopyWithImpl<$Res> extends _$EditorEventCopyWithImpl<$Res>
    implements _$$BringSelectedElementToFrontCopyWith<$Res> {
  __$$BringSelectedElementToFrontCopyWithImpl(
      _$BringSelectedElementToFront _value, $Res Function(_$BringSelectedElementToFront) _then)
      : super(_value, (v) => _then(v as _$BringSelectedElementToFront));

  @override
  _$BringSelectedElementToFront get _value => super._value as _$BringSelectedElementToFront;
}

/// @nodoc

class _$BringSelectedElementToFront implements BringSelectedElementToFront {
  const _$BringSelectedElementToFront();

  @override
  String toString() {
    return 'EditorEvent.bringSelectedElementToFront()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other.runtimeType == runtimeType && other is _$BringSelectedElementToFront);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() undo,
    required TResult Function() redo,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addStaticText,
    required TResult Function(String updatedText) staticTextChanged,
    required TResult Function(material.TextStyle updatedTextStyle) staticTextStyleChanged,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addVariableText,
    required TResult Function() variableTextFileChanged,
    required TResult Function(material.TextStyle updatedTextStyle) variableTextStyleChanged,
    required TResult Function() addImage,
    required TResult Function(material.Offset localPosition) dragStart,
    required TResult Function(material.Offset delta) dragUpdate,
    required TResult Function() dragEnd,
    required TResult Function(material.Offset localPosition) tap,
    required TResult Function() removeSelectedElement,
    required TResult Function() bringSelectedElementToFront,
    required TResult Function() clearEditor,
  }) {
    return bringSelectedElementToFront();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
  }) {
    return bringSelectedElementToFront?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
    required TResult orElse(),
  }) {
    if (bringSelectedElementToFront != null) {
      return bringSelectedElementToFront();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Undo value) undo,
    required TResult Function(Redo value) redo,
    required TResult Function(AddStaticText value) addStaticText,
    required TResult Function(StaticTextChanged value) staticTextChanged,
    required TResult Function(StaticTextStyleChanged value) staticTextStyleChanged,
    required TResult Function(AddVariableText value) addVariableText,
    required TResult Function(VariableTextFileChanged value) variableTextFileChanged,
    required TResult Function(VariableTextStyleChanged value) variableTextStyleChanged,
    required TResult Function(AddImage value) addImage,
    required TResult Function(DragStart value) dragStart,
    required TResult Function(DragUpdate value) dragUpdate,
    required TResult Function(DragEnd value) dragEnd,
    required TResult Function(Tap value) tap,
    required TResult Function(RemoveSelectedElement value) removeSelectedElement,
    required TResult Function(BringSelectedElementToFront value) bringSelectedElementToFront,
    required TResult Function(ClearEditor value) clearEditor,
  }) {
    return bringSelectedElementToFront(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
  }) {
    return bringSelectedElementToFront?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
    required TResult orElse(),
  }) {
    if (bringSelectedElementToFront != null) {
      return bringSelectedElementToFront(this);
    }
    return orElse();
  }
}

abstract class BringSelectedElementToFront implements EditorEvent {
  const factory BringSelectedElementToFront() = _$BringSelectedElementToFront;
}

/// @nodoc
abstract class _$$ClearEditorCopyWith<$Res> {
  factory _$$ClearEditorCopyWith(_$ClearEditor value, $Res Function(_$ClearEditor) then) =
      __$$ClearEditorCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ClearEditorCopyWithImpl<$Res> extends _$EditorEventCopyWithImpl<$Res>
    implements _$$ClearEditorCopyWith<$Res> {
  __$$ClearEditorCopyWithImpl(_$ClearEditor _value, $Res Function(_$ClearEditor) _then)
      : super(_value, (v) => _then(v as _$ClearEditor));

  @override
  _$ClearEditor get _value => super._value as _$ClearEditor;
}

/// @nodoc

class _$ClearEditor implements ClearEditor {
  const _$ClearEditor();

  @override
  String toString() {
    return 'EditorEvent.clearEditor()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other.runtimeType == runtimeType && other is _$ClearEditor);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() undo,
    required TResult Function() redo,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addStaticText,
    required TResult Function(String updatedText) staticTextChanged,
    required TResult Function(material.TextStyle updatedTextStyle) staticTextStyleChanged,
    required TResult Function(
            String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)
        addVariableText,
    required TResult Function() variableTextFileChanged,
    required TResult Function(material.TextStyle updatedTextStyle) variableTextStyleChanged,
    required TResult Function() addImage,
    required TResult Function(material.Offset localPosition) dragStart,
    required TResult Function(material.Offset delta) dragUpdate,
    required TResult Function() dragEnd,
    required TResult Function(material.Offset localPosition) tap,
    required TResult Function() removeSelectedElement,
    required TResult Function() bringSelectedElementToFront,
    required TResult Function() clearEditor,
  }) {
    return clearEditor();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
  }) {
    return clearEditor?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? undo,
    TResult Function()? redo,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addStaticText,
    TResult Function(String updatedText)? staticTextChanged,
    TResult Function(material.TextStyle updatedTextStyle)? staticTextStyleChanged,
    TResult Function(String initialText, material.TextDirection textDirection, double minWidth, double maxWidth)?
        addVariableText,
    TResult Function()? variableTextFileChanged,
    TResult Function(material.TextStyle updatedTextStyle)? variableTextStyleChanged,
    TResult Function()? addImage,
    TResult Function(material.Offset localPosition)? dragStart,
    TResult Function(material.Offset delta)? dragUpdate,
    TResult Function()? dragEnd,
    TResult Function(material.Offset localPosition)? tap,
    TResult Function()? removeSelectedElement,
    TResult Function()? bringSelectedElementToFront,
    TResult Function()? clearEditor,
    required TResult orElse(),
  }) {
    if (clearEditor != null) {
      return clearEditor();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Undo value) undo,
    required TResult Function(Redo value) redo,
    required TResult Function(AddStaticText value) addStaticText,
    required TResult Function(StaticTextChanged value) staticTextChanged,
    required TResult Function(StaticTextStyleChanged value) staticTextStyleChanged,
    required TResult Function(AddVariableText value) addVariableText,
    required TResult Function(VariableTextFileChanged value) variableTextFileChanged,
    required TResult Function(VariableTextStyleChanged value) variableTextStyleChanged,
    required TResult Function(AddImage value) addImage,
    required TResult Function(DragStart value) dragStart,
    required TResult Function(DragUpdate value) dragUpdate,
    required TResult Function(DragEnd value) dragEnd,
    required TResult Function(Tap value) tap,
    required TResult Function(RemoveSelectedElement value) removeSelectedElement,
    required TResult Function(BringSelectedElementToFront value) bringSelectedElementToFront,
    required TResult Function(ClearEditor value) clearEditor,
  }) {
    return clearEditor(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
  }) {
    return clearEditor?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Undo value)? undo,
    TResult Function(Redo value)? redo,
    TResult Function(AddStaticText value)? addStaticText,
    TResult Function(StaticTextChanged value)? staticTextChanged,
    TResult Function(StaticTextStyleChanged value)? staticTextStyleChanged,
    TResult Function(AddVariableText value)? addVariableText,
    TResult Function(VariableTextFileChanged value)? variableTextFileChanged,
    TResult Function(VariableTextStyleChanged value)? variableTextStyleChanged,
    TResult Function(AddImage value)? addImage,
    TResult Function(DragStart value)? dragStart,
    TResult Function(DragUpdate value)? dragUpdate,
    TResult Function(DragEnd value)? dragEnd,
    TResult Function(Tap value)? tap,
    TResult Function(RemoveSelectedElement value)? removeSelectedElement,
    TResult Function(BringSelectedElementToFront value)? bringSelectedElementToFront,
    TResult Function(ClearEditor value)? clearEditor,
    required TResult orElse(),
  }) {
    if (clearEditor != null) {
      return clearEditor(this);
    }
    return orElse();
  }
}

abstract class ClearEditor implements EditorEvent {
  const factory ClearEditor() = _$ClearEditor;
}

/// @nodoc
mixin _$EditorState {
  Editor get editor => throw _privateConstructorUsedError;
  Option<String> get draggedElementId => throw _privateConstructorUsedError;
  Option<ui.Offset> get dragPosition => throw _privateConstructorUsedError;
  Option<String> get selectedElementId => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $EditorStateCopyWith<EditorState> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EditorStateCopyWith<$Res> {
  factory $EditorStateCopyWith(EditorState value, $Res Function(EditorState) then) = _$EditorStateCopyWithImpl<$Res>;
  $Res call(
      {Editor editor,
      Option<String> draggedElementId,
      Option<ui.Offset> dragPosition,
      Option<String> selectedElementId});

  $EditorCopyWith<$Res> get editor;
}

/// @nodoc
class _$EditorStateCopyWithImpl<$Res> implements $EditorStateCopyWith<$Res> {
  _$EditorStateCopyWithImpl(this._value, this._then);

  final EditorState _value;
  // ignore: unused_field
  final $Res Function(EditorState) _then;

  @override
  $Res call({
    Object? editor = freezed,
    Object? draggedElementId = freezed,
    Object? dragPosition = freezed,
    Object? selectedElementId = freezed,
  }) {
    return _then(_value.copyWith(
      editor: editor == freezed
          ? _value.editor
          : editor // ignore: cast_nullable_to_non_nullable
              as Editor,
      draggedElementId: draggedElementId == freezed
          ? _value.draggedElementId
          : draggedElementId // ignore: cast_nullable_to_non_nullable
              as Option<String>,
      dragPosition: dragPosition == freezed
          ? _value.dragPosition
          : dragPosition // ignore: cast_nullable_to_non_nullable
              as Option<ui.Offset>,
      selectedElementId: selectedElementId == freezed
          ? _value.selectedElementId
          : selectedElementId // ignore: cast_nullable_to_non_nullable
              as Option<String>,
    ));
  }

  @override
  $EditorCopyWith<$Res> get editor {
    return $EditorCopyWith<$Res>(_value.editor, (value) {
      return _then(_value.copyWith(editor: value));
    });
  }
}

/// @nodoc
abstract class _$$_EditorStateCopyWith<$Res> implements $EditorStateCopyWith<$Res> {
  factory _$$_EditorStateCopyWith(_$_EditorState value, $Res Function(_$_EditorState) then) =
      __$$_EditorStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {Editor editor,
      Option<String> draggedElementId,
      Option<ui.Offset> dragPosition,
      Option<String> selectedElementId});

  @override
  $EditorCopyWith<$Res> get editor;
}

/// @nodoc
class __$$_EditorStateCopyWithImpl<$Res> extends _$EditorStateCopyWithImpl<$Res>
    implements _$$_EditorStateCopyWith<$Res> {
  __$$_EditorStateCopyWithImpl(_$_EditorState _value, $Res Function(_$_EditorState) _then)
      : super(_value, (v) => _then(v as _$_EditorState));

  @override
  _$_EditorState get _value => super._value as _$_EditorState;

  @override
  $Res call({
    Object? editor = freezed,
    Object? draggedElementId = freezed,
    Object? dragPosition = freezed,
    Object? selectedElementId = freezed,
  }) {
    return _then(_$_EditorState(
      editor: editor == freezed
          ? _value.editor
          : editor // ignore: cast_nullable_to_non_nullable
              as Editor,
      draggedElementId: draggedElementId == freezed
          ? _value.draggedElementId
          : draggedElementId // ignore: cast_nullable_to_non_nullable
              as Option<String>,
      dragPosition: dragPosition == freezed
          ? _value.dragPosition
          : dragPosition // ignore: cast_nullable_to_non_nullable
              as Option<ui.Offset>,
      selectedElementId: selectedElementId == freezed
          ? _value.selectedElementId
          : selectedElementId // ignore: cast_nullable_to_non_nullable
              as Option<String>,
    ));
  }
}

/// @nodoc

class _$_EditorState extends _EditorState {
  const _$_EditorState(
      {required this.editor,
      required this.draggedElementId,
      required this.dragPosition,
      required this.selectedElementId})
      : super._();

  @override
  final Editor editor;
  @override
  final Option<String> draggedElementId;
  @override
  final Option<ui.Offset> dragPosition;
  @override
  final Option<String> selectedElementId;

  @override
  String toString() {
    return 'EditorState(editor: $editor, draggedElementId: $draggedElementId, dragPosition: $dragPosition, selectedElementId: $selectedElementId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_EditorState &&
            const DeepCollectionEquality().equals(other.editor, editor) &&
            const DeepCollectionEquality().equals(other.draggedElementId, draggedElementId) &&
            const DeepCollectionEquality().equals(other.dragPosition, dragPosition) &&
            const DeepCollectionEquality().equals(other.selectedElementId, selectedElementId));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(editor),
      const DeepCollectionEquality().hash(draggedElementId),
      const DeepCollectionEquality().hash(dragPosition),
      const DeepCollectionEquality().hash(selectedElementId));

  @JsonKey(ignore: true)
  @override
  _$$_EditorStateCopyWith<_$_EditorState> get copyWith =>
      __$$_EditorStateCopyWithImpl<_$_EditorState>(this, _$identity);
}

abstract class _EditorState extends EditorState {
  const factory _EditorState(
      {required final Editor editor,
      required final Option<String> draggedElementId,
      required final Option<ui.Offset> dragPosition,
      required final Option<String> selectedElementId}) = _$_EditorState;
  const _EditorState._() : super._();

  @override
  Editor get editor => throw _privateConstructorUsedError;
  @override
  Option<String> get draggedElementId => throw _privateConstructorUsedError;
  @override
  Option<ui.Offset> get dragPosition => throw _privateConstructorUsedError;
  @override
  Option<String> get selectedElementId => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_EditorStateCopyWith<_$_EditorState> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$EditorStateError {
  String get message => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $EditorStateErrorCopyWith<EditorStateError> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EditorStateErrorCopyWith<$Res> {
  factory $EditorStateErrorCopyWith(EditorStateError value, $Res Function(EditorStateError) then) =
      _$EditorStateErrorCopyWithImpl<$Res>;
  $Res call({String message});
}

/// @nodoc
class _$EditorStateErrorCopyWithImpl<$Res> implements $EditorStateErrorCopyWith<$Res> {
  _$EditorStateErrorCopyWithImpl(this._value, this._then);

  final EditorStateError _value;
  // ignore: unused_field
  final $Res Function(EditorStateError) _then;

  @override
  $Res call({
    Object? message = freezed,
  }) {
    return _then(_value.copyWith(
      message: message == freezed
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_EditorStateErrorCopyWith<$Res> implements $EditorStateErrorCopyWith<$Res> {
  factory _$$_EditorStateErrorCopyWith(_$_EditorStateError value, $Res Function(_$_EditorStateError) then) =
      __$$_EditorStateErrorCopyWithImpl<$Res>;
  @override
  $Res call({String message});
}

/// @nodoc
class __$$_EditorStateErrorCopyWithImpl<$Res> extends _$EditorStateErrorCopyWithImpl<$Res>
    implements _$$_EditorStateErrorCopyWith<$Res> {
  __$$_EditorStateErrorCopyWithImpl(_$_EditorStateError _value, $Res Function(_$_EditorStateError) _then)
      : super(_value, (v) => _then(v as _$_EditorStateError));

  @override
  _$_EditorStateError get _value => super._value as _$_EditorStateError;

  @override
  $Res call({
    Object? message = freezed,
  }) {
    return _then(_$_EditorStateError(
      message == freezed
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_EditorStateError extends _EditorStateError {
  const _$_EditorStateError(this.message) : super._();

  @override
  final String message;

  @override
  String toString() {
    return 'EditorStateError(message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_EditorStateError &&
            const DeepCollectionEquality().equals(other.message, message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(message));

  @JsonKey(ignore: true)
  @override
  _$$_EditorStateErrorCopyWith<_$_EditorStateError> get copyWith =>
      __$$_EditorStateErrorCopyWithImpl<_$_EditorStateError>(this, _$identity);
}

abstract class _EditorStateError extends EditorStateError {
  const factory _EditorStateError(final String message) = _$_EditorStateError;
  const _EditorStateError._() : super._();

  @override
  String get message => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_EditorStateErrorCopyWith<_$_EditorStateError> get copyWith => throw _privateConstructorUsedError;
}
